=head1 Algorithmic Music with Perl

L<Gene Boggs (ology)|https://github.com/ology>

TPRC 2023 - Toronto, ON

=begin note

Let's talk about music!

The first part will cover often overlapping concepts - which I will whip-though.

I will skip the deep dive into types and techniques of algorithmic music,
so we can get to the meat of the second part: examples of actual algorithms.

Also, these slides are live at the link on the bottom of the pages.

=end note

=head1 What this talk is NOT about:

=over

=item *

Song / audio analysis

=item *

Real-time audio / MIDI processing

=item *

Low-level handling of MIDI events (e.g. note_on, note_off, sysex)

=item *

Artificial intelligence techniques (e.g. generative adversarial networks)

=item *

Kittens!

=back

=begin note

...

=end note

=head1 What this talk IS about:

=over

=item *

Procedural algorithms

=item *

High-level, OO MIDI score construction

=item *

Writing MIDI files

=item *

Applied music theory (i.e. algorithmic music "exercises" a theory)

=back

=begin note

...

=end note

=head1 What is Algorithmic Music?

Computer-assisted composition where algorithms are used to create musical material.

=over

=item *

For musical creations in and of themselves

=item *

To generate musical ideas and satisfy curiosity

=item *

For practice and study, with etudes and rhythms (i.e. a better metronome)

=item *

To import fragments into a larger context - possibly with a "digital audio workstation" (DAW)

=back

=begin note

DAWs like Reaper, Ableton, or Apple Logic, etc.

=end note

=head1 What is Algorithmic Music?

=over

=item *

Constructed with mathematical equations or grammars

=item *

Or randomized selection of notes, rhythms, and phrases

=item *

Or probabality logic to determine selection

=item *

Or stochastic processes

=item *

Or rule-based methods

=back

=begin note

...

=end note

=head1 Types of Algorithmic Music

"Generative"

=over

=item *

Term popularized by Brian Eno to describe music that is ever-different, changing, and created by a system

=item *

Algorithms that can create different versions of the same musical elements

=back

=begin note

Generative music is not necessarily alorithmic. For instance, Eno's Music for Airports #2 is actually a tape-loop physical system.

=end note

=head1 Types of Algorithmic Music

Rule-Based

=over

=item *

Uses grammars to generate compositions

=item *

Uses constraints to restrict compositions

=item *

Often composed according to a predetermined set of instructions

=back

=begin note

SKIP

=end note

=head1 Types of Algorithmic Music

Aleatoric and Statistical

=over

=item *

Use of randomness to create unique, sometimes complex and unpredictable sound

=item *

Use of probability

=item *

Use of stochastic processes

=back

=begin note

SKIP

=end note

=head1 Techniques for Generative Music

Repetition

=over

=item *

Used to create a sense of continuity and familiarity

=back

Variation

=over

=item *

Changing pitch, rhythm, or timbre of a phrase, also adding or removing elements

=back

Transformation

=over

=item *

Manipulating small details of a composition to create new, unique pieces of music

=back

=begin note

SKIP

=end note

=head1 Techniques for Rule-Based Music

Musical Grammars

=over

=item *

Structured sequences are created by creating a set of rules that determine which rhythms, notes, or phrases are chosen

=back

Constraints

=over

=item *

A constraint solver searches for solutions, where variables are bound to values of its domain without violating any constraints

=back

=begin note

SKIP

=end note

=head1 Techniques for Statistical Music

Randomness

=over

=item *

Random sequences are created by randomly choosing notes from a pool of possibilities

=back

Probability

=over

=item *

By changing the probabilities of rhythms, notes, chords, or phrases, different variations of a musical sequence can be created

=back

=begin note

SKIP

=end note

=head1 Techniques for Statistical Music

Stochastic processes

=over

=item *

Described by a random probability distribution

=back

Evolutionary methods

=over

=item *

Based on genetic algorithms using mutation and natural selection

=back

=begin note

SKIP

=end note

=head1 A Little Music Theory

=over

=item *

Basic elements: rhythm, harmony, and melody

=item *

Compositional elements: song form, tempo, meter, key signatures, intervals, scales, etc.

=item *

Qualities such as pitch, tone, timbre, texture, dynamics, etc.

=item *

A "motif" is a brief melodic or rhythmic formula out of which longer passages are developed

=back

=begin note

Other than dynamics and possibly texture, these qualities are not easily achieved with MIDI.

This (motif) term will be important later.

The concept of "development" is controversial. Some music doesn't develop phrases at all.

=end note

=head1 Fundamental Questions

=over

=item *

How do you construct a rhythm?

=item *

How do you generate pleasing harmony?

=item *

How do you make a melody?

=item *

How do you structure a tune?

=back

=begin note

These are the questions we will have to answer if we want to create algorithmic music that follows traditional theory.

If we don't care about traditions, then anything goes!

=end note

=head1 Music Construction Modules on CPAN

App::MusicTools Csound Guitar::Scale MIDI MIDI::Chord::Guitar L<MIDI::Drummer::Tiny|https://metacpan.org/dist/MIDI-Drummer-Tiny> MIDI::Morph MIDI::Pitch MIDI::Praxis::Variation MIDI::Simple::Drummer MIDI::SoundFont MIDI::Tools MIDI::Trans MIDI::Tweaks L<MIDI::Util|https://metacpan.org/dist/MIDI-Util> Music::AtonalUtil Music::Cadence Music::Canon Music::ChordBot Music::Chord::Namer L<Music::Chord::Note|https://metacpan.org/dist/Music-Chord-Note> Music::Chord::Positions Music::Chord::Progression Music::Chord::Progression::Transform Music::Duration L<Music::Duration::Partition|https://metacpan.org/dist/Music-Duration-Partition> Music::Gestalt Music::Guidonian Music::Harmonics Music::MelodicDevice::Inversion Music::MelodicDevice::Transposition Music::MelodicDevice::Ornamentation Music::NeoRiemannianTonnetz Music::Note Music::Note::Frequency Music::Note::Role::Operators Music::PitchNum Music::RecRhythm Music::RhythmSet Music::ScaleNote L<Music::Scales|https://metacpan.org/dist/Music-Scales> Music::Tempo Music::Tension Music::ToRoman Music::VoiceGen Music::Voss String::Approx Text::Chord::Piano = B<45+!>

=begin note

The linked modules are those mentioned in this presentation.

=end note

=head1 Basic Algorithms 1 of 2

=begin perl

use MIDI::Util qw(setup_score);

my $score = setup_score();

$score->synch(
    sub { bass($score) },
    sub { treble($score) },
) for 1 .. 2;

$score->write_score("$0.mid");

=end perl

=begin note

The following sets of slides are complete programs.

1st: score and synchronization.

=end note

=head1 Basic Algorithms 2 of 2

=begin perl

sub bass {
    my ($score) = @_;
    for my $note (qw(C3 F3 G3 C4)) {
        $score->n('hn', $note);
    }
}
sub treble {
    my ($score) = @_;
    for my $note (qw(C4 D4 E4 F4)) {
        $score->n('qn', $note);
        $score->r('qn');
    }
}

=end perl

=begin note

> vim ex-02-02.pl
:!rm %.mid ; perl % ; timidity %.mid

2nd: sychornized parts.

Here we use literal notes with octaves.

Also this is the "proper" way to do things, in terms of CS. But...

=end note

=head1 Basic Algorithms 1 of 3

=begin perl

use MIDI::Util qw(setup_score set_chan_patch);
use Music::Scales qw(get_scale_MIDI);

my $score = setup_score(bpm => 120, volume => 120);

$score->synch(
    \&bass,
    \&treble,
) for 1 .. 2;

$score->write_score("$0.mid");

=end perl

=begin note

Filthy globals!

Music programs are not "mission critical."

They are not "time-sensitive." Not "real-time."

1st: Music::Scales and score settings.

=end note

=head1 Basic Algorithms 2 of 3

=begin perl

sub bass {
    set_chan_patch($score, 0, 35);

    my @pitches = get_scale_MIDI('C', 2, 'pentatonic');

    for my $n (1 .. 4) {
        my $pitch = $pitches[int rand @pitches];
        $score->n('hn', $pitch);
    }
}

=end perl

=begin note

And here is the bass part.

2nd: Fretless bass patch on channel zero.
Scale pitches in a non-clashing scale.
Add four random pitches to the score, for a half-note each.

=end note

=head1 Basic Algorithms 3 of 3

=begin perl

sub treble {
    set_chan_patch($score, 1, 0);

    my @pitches = (
        get_scale_MIDI('C', 4, 'major'),
        get_scale_MIDI('C', 5, 'major'),
    );

    for my $n (1 .. 4) {
        my $pitch = $pitches[int rand @pitches];
        $score->n('qn', $pitch);
        $score->r('qn');
    }
}

=end perl

=begin note

> vim ex-04-03.pl
:!rm %.mid ; perl % ; timidity %.mid

Treble uses two octaves, as opposed to the bass part's one.

Instead of half-notes, add a quarter-note and a quarter-rest.

=end note

=head1 Basic Algorithms 1 of 2

=begin perl

use Data::Dumper::Compact qw(ddc);
use MIDI::Util qw(setup_score midi_format);
use Music::Chord::Note ();

my $score = setup_score();

my $mcn = Music::Chord::Note->new;

=end perl

=begin note

This slide just introduces the next slide.

But we instantiate a new chord-to-notes object first.

=end note

=head1 Basic Algorithms 2 of 2

=begin perl

for my $c (qw(Cm7 F7 BbM7 EbM7 Adim7 D7 Gm)) {
    my @chord = $mcn->chord_with_octave($c, 4);

    @chord = midi_format(@chord);
    print ddc(\@chord); # [ 'C4', 'Ds4', 'G4', 'As4' ], etc.

    $score->n('wn', @chord);
}

$score->write_score("$0.mid");

=end perl

=begin note

> vim ex-08-02.pl
:!rm %.mid ; perl % ; timidity %.mid

Here is the meat of the algorithm: Play a list of named chords held for a whole note each.

=end note

=head1 GrooveTool

=over

=item *

Generates combinatorial rhythmic patterns, e.g. Euclidean and Christoffel words

=item *

Produces a randomized, figured bass part

=item *

morbo groovetool.pl # L<http://127.0.0.1:3000>

=back

=begin note

...

=end note

=head1 Instantiate a Drummer

=begin perl

my $d = MIDI::Drummer::Tiny->new(
    file   => $filename,
    bars   => 4 * $repeat,
    bpm    => $bpm,
    reverb => $reverb,
    volume => $volume,
    # etc...
);

=end perl

=begin note

Everything you need to add drums to a MIDI score and more.

For the GrooveTool, combinatorial patterns are "juxtaposed" - i.e. beats!

=end note

=head1 Drummer Decisions

=begin perl

if ($part->{style} eq 'euclid') {
    push @phrases, sub { $self->euclidean_part($part, $key) };
}
elsif ($part->{style} eq 'christoffel') {
    push @phrases, sub { $self->christoffel_part($part, $key) };
}
elsif ($part->{style} eq 'pfold') {
    push @phrases, sub { $self->pfold_part($part, $key) };
}

=end perl

=begin note

Where the $key is a unique phrase identifier.

And "pfold" is another type of combinatorial pattern that can be generated.

Now that I look at it, looks like I could simplify the syntax with a dispatch table

=end note

=head1 Figured Bass Part 1 of 2

=begin perl

my $mdp = Music::Duration::Partition->new(
    size    => 4, # number of beats to render
    pool    => [qw(hn dqn qn en)],
    weights => [ 1, 1, 2, 2 ],
    groups  => [ 1, 1, 1, 2 ],
);

my @motifs = map { $mdp->motif } 1 .. $motif_number;

=end perl

=begin note

Phrase generator for bass rhythmic motifs

=end note

=head1 Figured Bass Part 2 of 2

=begin perl

my @pitches = get_scale_MIDI($note, $octave, $scale);

my $voice = Music::VoiceGen->new(
    pitches   => \@pitches,
    intervals => [qw/-4 -3 -2 2 3 4/],

);

my @notes1 = map { $voice->rand } $motifs[0]->@*;
my @notes2 = map { $voice->rand } $motifs[1]->@*;

=end perl

=begin note

Voices with the excellent Music::VoiceGen module by Jeremy Mates (AKA thrig)

=end note

=head1 Links

L<This Slideshow|https://ology.net/dev/Perl-Algorithmic-Music/>
(L<on GitHub|https://github.com/ology/Perl-Algorithmic-Music>
and L<made with S5|https://metacpan.org/dist/Pod-S5>)

L<Perl Algorithmic Composition Wiki|https://github.com/ology/MIDI-Perl-HOWTO/wiki>

L<The GrooveTool|https://github.com/ology/Groove-Tool> on GitHub

My musical experiments with MIDI-Perl L<on GitHub|https://github.com/ology/Music/>

Shameless plug: My L<latest album "XI"|https://ology.net/XI/> is on youtube, spotify, apple music, etc., and includes the partially algorithmic tune, "Permutational." Check it out!

=cut
